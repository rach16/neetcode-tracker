import { AlgoTip, Pattern } from '../types';

// Visual icons and memory aids for each pattern
export const PATTERN_VISUALS: Record<Pattern, { icon: string; visual: string; gesture: string }> = {
  'HashMap': { icon: 'üì¶', visual: 'Key unlocks value box', gesture: 'Key turning in lock' },
  'HashSet': { icon: 'üéØ', visual: 'Unique dots on dartboard', gesture: 'Tapping targets' },
  'Two Pointers': { icon: 'üëÜüëÜ', visual: 'Two fingers walking toward each other', gesture: 'Pinch gesture' },
  'Sliding Window': { icon: 'ü™ü', visual: 'Moving window frame across landscape', gesture: 'Sliding hands' },
  'Stack': { icon: 'üìö', visual: 'Stack of books - LIFO', gesture: 'Stacking plates' },
  'Monotonic Stack': { icon: 'üìä', visual: 'Stairs going one direction', gesture: 'Steps up/down' },
  'Binary Search': { icon: '‚úÇÔ∏è', visual: 'Cutting phone book in half', gesture: 'Book splitting' },
  'Linked List': { icon: 'üîó', visual: 'Chain links connected', gesture: 'Paper chain' },
  'Fast & Slow Pointers': { icon: 'üê¢üêá', visual: 'Tortoise and hare race', gesture: 'Two speeds' },
  'Tree DFS': { icon: 'üå≤', visual: 'Diving down tree branches', gesture: 'Going deep' },
  'Tree BFS': { icon: 'üå≥', visual: 'Scanning tree level by level', gesture: 'Horizontal sweep' },
  'Trie': { icon: 'üî§', visual: 'Branching letters like autocomplete', gesture: 'Typing suggestions' },
  'Heap': { icon: '‚õ∞Ô∏è', visual: 'Priority mountain - top is special', gesture: 'Bubbling up' },
  'Backtracking': { icon: 'üîô', visual: 'Maze with breadcrumbs', gesture: 'Try, fail, undo' },
  'Graph DFS': { icon: 'üï∏Ô∏è', visual: 'Spider exploring web deeply', gesture: 'Deep dive' },
  'Graph BFS': { icon: 'üåä', visual: 'Ripples spreading outward', gesture: 'Expanding circles' },
  'Union Find': { icon: 'ü§ù', visual: 'Friend groups merging', gesture: 'Handshake' },
  'Topological Sort': { icon: 'üìã', visual: 'Prerequisites chain', gesture: 'Dependency arrows' },
  'DP': { icon: 'üß©', visual: 'Building from solved pieces', gesture: 'Puzzle assembly' },
  'Greedy': { icon: 'ü§ë', visual: 'Always grab the best now', gesture: 'Grabbing coins' },
  'Intervals': { icon: 'üìÖ', visual: 'Calendar time blocks', gesture: 'Timeline bars' },
  'Bit Manipulation': { icon: 'üí°', visual: 'Light switches on/off', gesture: 'Toggle switches' },
  'Math': { icon: 'üî¢', visual: 'Calculator patterns', gesture: 'Number crunching' },
};

// Complexity hints for quick recognition
export const COMPLEXITY_HINTS: Record<string, { time: string; space: string; hint: string }> = {
  'HashMap': { time: 'O(n)', space: 'O(n)', hint: 'Trade space for time' },
  'HashSet': { time: 'O(n)', space: 'O(n)', hint: 'Trade space for lookup' },
  'Two Pointers': { time: 'O(n)', space: 'O(1)', hint: 'No extra space needed' },
  'Sliding Window': { time: 'O(n)', space: 'O(1) or O(k)', hint: 'Window size matters' },
  'Stack': { time: 'O(n)', space: 'O(n)', hint: 'Each element once' },
  'Monotonic Stack': { time: 'O(n)', space: 'O(n)', hint: 'Amortized linear' },
  'Binary Search': { time: 'O(log n)', space: 'O(1)', hint: 'Halving is powerful' },
  'Linked List': { time: 'O(n)', space: 'O(1)', hint: 'In-place is possible' },
  'Fast & Slow Pointers': { time: 'O(n)', space: 'O(1)', hint: 'Detect cycles cleverly' },
  'Tree DFS': { time: 'O(n)', space: 'O(h)', hint: 'Height = recursion depth' },
  'Tree BFS': { time: 'O(n)', space: 'O(w)', hint: 'Width = queue size' },
  'Trie': { time: 'O(m)', space: 'O(m*n)', hint: 'm = word length' },
  'Heap': { time: 'O(n log k)', space: 'O(k)', hint: 'k = heap size' },
  'Backtracking': { time: 'O(2^n) or O(n!)', space: 'O(n)', hint: 'Exponential but prunable' },
  'Graph DFS': { time: 'O(V+E)', space: 'O(V)', hint: 'Visit each once' },
  'Graph BFS': { time: 'O(V+E)', space: 'O(V)', hint: 'Queue holds frontier' },
  'Union Find': { time: 'O(Œ±(n))', space: 'O(n)', hint: 'Nearly constant' },
  'Topological Sort': { time: 'O(V+E)', space: 'O(V)', hint: 'Linear in graph size' },
  'DP': { time: 'O(n¬≤) typically', space: 'O(n) or O(n¬≤)', hint: 'Subproblems count' },
  'Greedy': { time: 'O(n log n)', space: 'O(1)', hint: 'Often needs sorting' },
  'Intervals': { time: 'O(n log n)', space: 'O(n)', hint: 'Sort first usually' },
  'Bit Manipulation': { time: 'O(n) or O(1)', space: 'O(1)', hint: 'Constant extra space' },
  'Math': { time: 'O(log n) often', space: 'O(1)', hint: 'Mathematical insight' },
};

export const PATTERN_TRIGGERS: { pattern: Pattern; trigger: string }[] = [
  { pattern: 'HashMap', trigger: '"Have I seen this before?" / Need O(1) lookup' },
  { pattern: 'HashSet', trigger: 'Check existence, find duplicates' },
  { pattern: 'Two Pointers', trigger: 'Sorted array, find pair, palindrome' },
  { pattern: 'Sliding Window', trigger: 'Contiguous subarray/substring with constraint' },
  { pattern: 'Stack', trigger: 'Matching pairs, next greater/smaller, parsing' },
  { pattern: 'Monotonic Stack', trigger: 'Next greater/smaller element' },
  { pattern: 'Binary Search', trigger: 'Sorted data, minimize/maximize something' },
  { pattern: 'Linked List', trigger: 'In-place reversal, cycle detection, merge' },
  { pattern: 'Fast & Slow Pointers', trigger: 'Cycle detection, find middle' },
  { pattern: 'Tree DFS', trigger: 'Path problems, validate structure' },
  { pattern: 'Tree BFS', trigger: 'Level-order, shortest path in tree' },
  { pattern: 'Trie', trigger: 'Prefix matching, word dictionary' },
  { pattern: 'Heap', trigger: 'K-th largest/smallest, merge sorted things' },
  { pattern: 'Backtracking', trigger: 'Generate all possibilities, combinations' },
  { pattern: 'Graph BFS', trigger: 'Shortest unweighted path, level traversal' },
  { pattern: 'Graph DFS', trigger: 'Connected components, cycle detection' },
  { pattern: 'Union Find', trigger: 'Dynamic connectivity, redundant edges' },
  { pattern: 'Topological Sort', trigger: 'Dependencies, course schedule' },
  { pattern: 'DP', trigger: 'Optimal substructure + overlapping subproblems' },
  { pattern: 'Greedy', trigger: 'Local optimal = global optimal' },
  { pattern: 'Intervals', trigger: 'Sort by start/end, merge/count overlaps' },
  { pattern: 'Bit Manipulation', trigger: 'XOR for pairing, AND/OR for checking bits' },
  { pattern: 'Math', trigger: 'Number properties, modular arithmetic' },
];

export const algoTips: AlgoTip[] = [
  // Arrays & Hashing (1-9)
  {
    problemId: 'contains-duplicate',
    problemName: 'Contains Duplicate',
    category: 'arrays-hashing',
    pattern: 'HashSet',
    oneLiner: 'Set rejects duplicates - if you can\'t add it, you\'ve seen it',
    keyQuestion: 'Do I need to check if something exists?',
  },
  {
    problemId: 'valid-anagram',
    problemName: 'Valid Anagram',
    category: 'arrays-hashing',
    pattern: 'HashMap',
    oneLiner: 'Same letters, same counts = anagram',
    memoryHook: 'Count and compare',
  },
  {
    problemId: 'two-sum',
    problemName: 'Two Sum',
    category: 'arrays-hashing',
    pattern: 'HashMap',
    oneLiner: 'Don\'t search for the number, search for what\'s MISSING (target - num)',
    keyQuestion: 'Can I store what I need to find?',
    commonMistake: 'Using the same element twice',
  },
  {
    problemId: 'group-anagrams',
    problemName: 'Group Anagrams',
    category: 'arrays-hashing',
    pattern: 'HashMap',
    oneLiner: 'Anagrams become identical when sorted - that\'s your grouping key',
    memoryHook: 'Sort to match, group by key',
  },
  {
    problemId: 'top-k-frequent-elements',
    problemName: 'Top K Frequent Elements',
    category: 'arrays-hashing',
    pattern: 'Heap',
    oneLiner: 'Count first, then get top K',
    memoryHook: 'Count -> Rank -> Pick',
  },
  {
    problemId: 'encode-and-decode-strings',
    problemName: 'Encode and Decode Strings',
    category: 'arrays-hashing',
    pattern: 'HashMap',
    oneLiner: 'Store length before each string so you know where it ends',
    memoryHook: 'Length#String format',
  },
  {
    problemId: 'product-of-array-except-self',
    problemName: 'Product of Array Except Self',
    category: 'arrays-hashing',
    pattern: 'HashMap',
    oneLiner: 'Product at i = (everything left) x (everything right)',
    keyQuestion: 'Can I precompute from both directions?',
    commonMistake: 'Trying to use division',
  },
  {
    problemId: 'valid-sudoku',
    problemName: 'Valid Sudoku',
    category: 'arrays-hashing',
    pattern: 'HashSet',
    oneLiner: 'Three checks - row, column, 3x3 box. Box = (r//3, c//3)',
    memoryHook: 'Row, Col, Box - three sets per each',
  },
  {
    problemId: 'longest-consecutive-sequence',
    problemName: 'Longest Consecutive Sequence',
    category: 'arrays-hashing',
    pattern: 'HashSet',
    oneLiner: 'Only start counting from sequence BEGINNING (num-1 not in set)',
    keyQuestion: 'Am I at the start of a sequence?',
    commonMistake: 'Counting from every number (O(n^2))',
  },

  // Two Pointers (10-14)
  {
    problemId: 'valid-palindrome',
    problemName: 'Valid Palindrome',
    category: 'two-pointers',
    pattern: 'Two Pointers',
    oneLiner: 'Compare from outside in, skip non-alphanumeric',
    memoryHook: 'Meet in the middle',
  },
  {
    problemId: 'two-sum-ii-input-array-is-sorted',
    problemName: 'Two Sum II (Sorted)',
    category: 'two-pointers',
    pattern: 'Two Pointers',
    oneLiner: 'Too big? Move right pointer left. Too small? Move left pointer right.',
    keyQuestion: 'Is the array sorted?',
  },
  {
    problemId: '3sum',
    problemName: '3Sum',
    category: 'two-pointers',
    pattern: 'Two Pointers',
    oneLiner: 'Fix one number, two-pointer the rest. Sort first to skip duplicates.',
    commonMistake: 'Forgetting to skip duplicates at both levels',
  },
  {
    problemId: 'container-with-most-water',
    problemName: 'Container With Most Water',
    category: 'two-pointers',
    pattern: 'Two Pointers',
    oneLiner: 'Always move the SHORTER line - it\'s the only way to potentially gain',
    memoryHook: 'Short line is the bottleneck',
  },
  {
    problemId: 'trapping-rain-water',
    problemName: 'Trapping Rain Water',
    category: 'two-pointers',
    pattern: 'Two Pointers',
    oneLiner: 'Water at position = min(maxLeft, maxRight) - height',
    memoryHook: 'Water fills to the lower wall',
  },

  // Sliding Window (15-20)
  {
    problemId: 'best-time-to-buy-and-sell-stock',
    problemName: 'Best Time to Buy and Sell Stock',
    category: 'sliding-window',
    pattern: 'Sliding Window',
    oneLiner: 'Track lowest price seen, profit = today - lowest',
    memoryHook: 'Buy low, sell high, track the low',
  },
  {
    problemId: 'longest-substring-without-repeating-characters',
    problemName: 'Longest Substring Without Repeating',
    category: 'sliding-window',
    pattern: 'Sliding Window',
    oneLiner: 'Expand right, shrink left when duplicate appears',
    keyQuestion: 'What makes my window invalid?',
  },
  {
    problemId: 'longest-repeating-character-replacement',
    problemName: 'Longest Repeating Character Replacement',
    category: 'sliding-window',
    pattern: 'Sliding Window',
    oneLiner: 'Window is valid if (length - maxFreq) <= k',
    memoryHook: 'How many do I need to replace?',
  },
  {
    problemId: 'permutation-in-string',
    problemName: 'Permutation in String',
    category: 'sliding-window',
    pattern: 'Sliding Window',
    oneLiner: 'Window size = len(s1), slide and compare counts',
    keyQuestion: 'Is my window the right size?',
  },
  {
    problemId: 'minimum-window-substring',
    problemName: 'Minimum Window Substring',
    category: 'sliding-window',
    pattern: 'Sliding Window',
    oneLiner: 'Expand until valid, shrink to optimize',
    memoryHook: 'Grow to satisfy, shrink to minimize',
  },
  {
    problemId: 'sliding-window-maximum',
    problemName: 'Sliding Window Maximum',
    category: 'sliding-window',
    pattern: 'Monotonic Stack',
    oneLiner: 'Deque stores indices in decreasing order, front is always max',
    keyQuestion: 'Do I need to track max/min in a window?',
  },

  // Stack (21-27)
  {
    problemId: 'valid-parentheses',
    problemName: 'Valid Parentheses',
    category: 'stack',
    pattern: 'Stack',
    oneLiner: 'Push open brackets, pop and match for close brackets',
    memoryHook: 'LIFO matches nested structure',
  },
  {
    problemId: 'min-stack',
    problemName: 'Min Stack',
    category: 'stack',
    pattern: 'Stack',
    oneLiner: 'Store (value, currentMin) so min is always accessible',
    keyQuestion: 'What state do I need to restore on pop?',
  },
  {
    problemId: 'evaluate-reverse-polish-notation',
    problemName: 'Evaluate Reverse Polish Notation',
    category: 'stack',
    pattern: 'Stack',
    oneLiner: 'Numbers -> push. Operators -> pop two, compute, push result.',
    memoryHook: 'Operands wait, operators act',
  },
  {
    problemId: 'generate-parentheses',
    problemName: 'Generate Parentheses',
    category: 'stack',
    pattern: 'Backtracking',
    oneLiner: 'Can add \'(\' if open < n. Can add \')\' if close < open.',
    memoryHook: 'Open freely, close responsibly',
  },
  {
    problemId: 'daily-temperatures',
    problemName: 'Daily Temperatures',
    category: 'stack',
    pattern: 'Monotonic Stack',
    oneLiner: 'Stack holds indices waiting for a warmer day',
    keyQuestion: 'Am I looking for the NEXT greater/smaller?',
  },
  {
    problemId: 'car-fleet',
    problemName: 'Car Fleet',
    category: 'stack',
    pattern: 'Stack',
    oneLiner: 'Sort by position desc, stack times. Slower car ahead = merge.',
    memoryHook: 'Can\'t pass, must merge',
  },
  {
    problemId: 'largest-rectangle-in-histogram',
    problemName: 'Largest Rectangle in Histogram',
    category: 'stack',
    pattern: 'Monotonic Stack',
    oneLiner: 'For each bar, find first smaller bar on left AND right',
    keyQuestion: 'How far can this element extend?',
  },

  // Binary Search (28-34)
  {
    problemId: 'binary-search',
    problemName: 'Binary Search',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'l <= r, mid = (l+r)//2, adjust based on comparison',
    commonMistake: 'Off-by-one on boundaries',
  },
  {
    problemId: 'search-a-2d-matrix',
    problemName: 'Search a 2D Matrix',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'Treat as 1D array: row = mid // cols, col = mid % cols',
    memoryHook: 'Flatten mentally, binary search normally',
  },
  {
    problemId: 'koko-eating-bananas',
    problemName: 'Koko Eating Bananas',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'Search for minimum speed K where total hours <= H',
    keyQuestion: 'Am I searching for an optimal VALUE, not index?',
  },
  {
    problemId: 'find-minimum-in-rotated-sorted-array',
    problemName: 'Find Minimum in Rotated Sorted Array',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'If mid > right, minimum is in right half',
    memoryHook: 'Bigger than right = rotation happened',
  },
  {
    problemId: 'search-in-rotated-sorted-array',
    problemName: 'Search in Rotated Sorted Array',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'One half is always sorted - check if target is in that half',
    keyQuestion: 'Which half is definitely sorted?',
  },
  {
    problemId: 'time-based-key-value-store',
    problemName: 'Time Based Key-Value Store',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'Store list of (timestamp, value), binary search for <= timestamp',
    memoryHook: 'Store in order, search with binary',
  },
  {
    problemId: 'median-of-two-sorted-arrays',
    problemName: 'Median of Two Sorted Arrays',
    category: 'binary-search',
    pattern: 'Binary Search',
    oneLiner: 'Find partition where maxLeft <= minRight in both arrays',
    memoryHook: 'Balance the halves',
  },

  // Linked List (35-45)
  {
    problemId: 'reverse-linked-list',
    problemName: 'Reverse Linked List',
    category: 'linked-list',
    pattern: 'Linked List',
    oneLiner: 'Save next, point curr to prev, move forward',
    memoryHook: 'Save, flip, advance',
  },
  {
    problemId: 'merge-two-sorted-lists',
    problemName: 'Merge Two Sorted Lists',
    category: 'linked-list',
    pattern: 'Linked List',
    oneLiner: 'Compare heads, link smaller, advance that pointer',
    memoryHook: 'Always pick the smaller head',
  },
  {
    problemId: 'linked-list-cycle',
    problemName: 'Linked List Cycle',
    category: 'linked-list',
    pattern: 'Fast & Slow Pointers',
    oneLiner: 'If fast catches slow, there\'s a cycle',
    memoryHook: 'Tortoise and hare meet in a loop',
  },
  {
    problemId: 'reorder-list',
    problemName: 'Reorder List',
    category: 'linked-list',
    pattern: 'Linked List',
    oneLiner: 'Split at middle, reverse second half, interleave',
    memoryHook: 'Split, flip, zip',
  },
  {
    problemId: 'remove-nth-node-from-end-of-list',
    problemName: 'Remove Nth Node From End',
    category: 'linked-list',
    pattern: 'Two Pointers',
    oneLiner: 'Create N-node gap, when fast hits end, slow is at target',
    memoryHook: 'Fast gets a head start',
  },
  {
    problemId: 'copy-list-with-random-pointer',
    problemName: 'Copy List with Random Pointer',
    category: 'linked-list',
    pattern: 'HashMap',
    oneLiner: 'First pass: create nodes. Second pass: link next and random.',
    memoryHook: 'Clone first, connect second',
  },
  {
    problemId: 'add-two-numbers',
    problemName: 'Add Two Numbers',
    category: 'linked-list',
    pattern: 'Linked List',
    oneLiner: 'Add digits + carry, new digit = sum % 10, carry = sum // 10',
    memoryHook: 'Elementary school addition',
  },
  {
    problemId: 'find-the-duplicate-number',
    problemName: 'Find the Duplicate Number',
    category: 'linked-list',
    pattern: 'Fast & Slow Pointers',
    oneLiner: 'Treat as linked list (val points to next index), find cycle start',
    memoryHook: 'It\'s a linked list in disguise',
  },
  {
    problemId: 'lru-cache',
    problemName: 'LRU Cache',
    category: 'linked-list',
    pattern: 'Linked List',
    oneLiner: 'Map for O(1) access, DLL for O(1) reorder',
    memoryHook: 'Map finds it, list orders it',
  },
  {
    problemId: 'merge-k-sorted-lists',
    problemName: 'Merge K Sorted Lists',
    category: 'linked-list',
    pattern: 'Heap',
    oneLiner: 'Heap always gives smallest head, push its next',
    memoryHook: 'Heap picks the winner',
  },
  {
    problemId: 'reverse-nodes-in-k-group',
    problemName: 'Reverse Nodes in K-Group',
    category: 'linked-list',
    pattern: 'Linked List',
    oneLiner: 'Check if K nodes exist, reverse them, connect to recursed rest',
    memoryHook: 'Count, flip, connect',
  },

  // Trees (46-60)
  {
    problemId: 'invert-binary-tree',
    problemName: 'Invert Binary Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Swap left and right, recurse on both',
    memoryHook: 'Mirror image recursively',
  },
  {
    problemId: 'maximum-depth-of-binary-tree',
    problemName: 'Maximum Depth of Binary Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Depth = 1 + max(left depth, right depth)',
    memoryHook: 'Go deep, count on the way up',
  },
  {
    problemId: 'diameter-of-binary-tree',
    problemName: 'Diameter of Binary Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Diameter through node = left height + right height',
    commonMistake: 'Forgetting diameter might not pass through root',
  },
  {
    problemId: 'balanced-binary-tree',
    problemName: 'Balanced Binary Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Return -1 if unbalanced, propagate up',
    memoryHook: '-1 is the poison pill',
  },
  {
    problemId: 'same-tree',
    problemName: 'Same Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Same if roots equal AND both subtrees same',
    memoryHook: 'Match root, recurse children',
  },
  {
    problemId: 'subtree-of-another-tree',
    problemName: 'Subtree of Another Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Check if any node starts a matching tree',
    memoryHook: 'Try matching at every node',
  },
  {
    problemId: 'lowest-common-ancestor-of-a-binary-search-tree',
    problemName: 'Lowest Common Ancestor (BST)',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Both smaller -> go left. Both bigger -> go right. Split -> found it.',
    memoryHook: 'Follow until they split',
  },
  {
    problemId: 'binary-tree-level-order-traversal',
    problemName: 'Binary Tree Level Order Traversal',
    category: 'trees',
    pattern: 'Tree BFS',
    oneLiner: 'Queue, process level by level using len(queue)',
    memoryHook: 'Drain one level, fill the next',
  },
  {
    problemId: 'binary-tree-right-side-view',
    problemName: 'Binary Tree Right Side View',
    category: 'trees',
    pattern: 'Tree BFS',
    oneLiner: 'Level order, keep last node of each level',
    memoryHook: 'Last one standing at each level',
  },
  {
    problemId: 'count-good-nodes-in-binary-tree',
    problemName: 'Count Good Nodes',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Good if node.val >= max on path from root',
    memoryHook: 'Beat or match the max to be good',
  },
  {
    problemId: 'validate-binary-search-tree',
    problemName: 'Validate BST',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Node must be > min bound AND < max bound',
    commonMistake: 'Only checking immediate children',
  },
  {
    problemId: 'kth-smallest-element-in-a-bst',
    problemName: 'Kth Smallest in BST',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Inorder = sorted order in BST, return Kth',
    memoryHook: 'Inorder is sorted',
  },
  {
    problemId: 'construct-binary-tree-from-preorder-and-inorder-traversal',
    problemName: 'Build Tree from Preorder & Inorder',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Preorder[0] is root, find it in inorder to split left/right',
    memoryHook: 'Pre gives root, in gives split',
  },
  {
    problemId: 'binary-tree-maximum-path-sum',
    problemName: 'Binary Tree Max Path Sum',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Path through node = node + max(0, left) + max(0, right)',
    commonMistake: 'Forgetting negative paths should be ignored (use 0)',
  },
  {
    problemId: 'serialize-and-deserialize-binary-tree',
    problemName: 'Serialize and Deserialize Binary Tree',
    category: 'trees',
    pattern: 'Tree DFS',
    oneLiner: 'Preorder traversal, \'N\' for null, comma-separated',
    memoryHook: 'Preorder with placeholders',
  },

  // Tries (61-63)
  {
    problemId: 'implement-trie-prefix-tree',
    problemName: 'Implement Trie',
    category: 'tries',
    pattern: 'Trie',
    oneLiner: 'Each node has children map + isEndOfWord flag',
    memoryHook: 'Characters as edges, words end with a flag',
  },
  {
    problemId: 'design-add-and-search-words-data-structure',
    problemName: 'Add and Search Words (with \'.\')',
    category: 'tries',
    pattern: 'Trie',
    oneLiner: '\'.\'  = try ALL children recursively',
    memoryHook: 'Dot means branch out',
  },
  {
    problemId: 'word-search-ii',
    problemName: 'Word Search II',
    category: 'tries',
    pattern: 'Trie',
    oneLiner: 'Build trie of words, DFS from each cell following trie',
    memoryHook: 'Trie guides the search',
  },

  // Heap / Priority Queue (64-70)
  {
    problemId: 'kth-largest-element-in-a-stream',
    problemName: 'Kth Largest Element in Stream',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Keep K largest in min heap, root is Kth largest',
    memoryHook: 'Min heap kicks out the smallest loser',
  },
  {
    problemId: 'last-stone-weight',
    problemName: 'Last Stone Weight',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Always smash two heaviest, push difference if any',
    memoryHook: 'Heaviest first (negate for max heap)',
  },
  {
    problemId: 'k-closest-points-to-origin',
    problemName: 'K Closest Points to Origin',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Max heap by distance, evict farthest when > K',
    memoryHook: 'Keep close, kick far',
  },
  {
    problemId: 'kth-largest-element-in-an-array',
    problemName: 'Kth Largest Element in Array',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Min heap of K elements, or partition like quicksort',
    memoryHook: 'Heap for easy, quickselect for optimal',
  },
  {
    problemId: 'task-scheduler',
    problemName: 'Task Scheduler',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Always run most frequent available task',
    memoryHook: 'Greedy on frequency, respect cooldown',
  },
  {
    problemId: 'design-twitter',
    problemName: 'Design Twitter',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Each user has tweet list, merge K lists for feed',
    memoryHook: 'Personal lists, merged feed',
  },
  {
    problemId: 'find-median-from-data-stream',
    problemName: 'Find Median from Data Stream',
    category: 'heap-priority-queue',
    pattern: 'Heap',
    oneLiner: 'Small half in max heap, large half in min heap, balance sizes',
    memoryHook: 'Two heaps meet at the median',
  },

  // Backtracking (71-79)
  {
    problemId: 'subsets',
    problemName: 'Subsets',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'For each element: include and recurse, exclude and recurse',
    memoryHook: 'Take it or leave it',
  },
  {
    problemId: 'combination-sum',
    problemName: 'Combination Sum',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Can reuse same element (don\'t increment index after include)',
    memoryHook: 'Stay or move on',
  },
  {
    problemId: 'permutations',
    problemName: 'Permutations',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Try each unused element at each position',
    memoryHook: 'Everyone gets a turn at each spot',
  },
  {
    problemId: 'subsets-ii',
    problemName: 'Subsets II (with duplicates)',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Sort first, skip if same as previous at same level',
    memoryHook: 'Sort to see duplicates, skip at same level',
  },
  {
    problemId: 'combination-sum-ii',
    problemName: 'Combination Sum II (no reuse)',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Like Combination Sum but move to next index, skip duplicates',
    memoryHook: 'Use once, skip copies',
  },
  {
    problemId: 'word-search',
    problemName: 'Word Search',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Mark visited, try 4 directions, unmark on backtrack',
    memoryHook: 'Visit, explore, unvisit',
  },
  {
    problemId: 'palindrome-partitioning',
    problemName: 'Palindrome Partitioning',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Try all palindrome prefixes, recurse on rest',
    memoryHook: 'Chop valid palindrome, recurse remainder',
  },
  {
    problemId: 'letter-combinations-of-a-phone-number',
    problemName: 'Letter Combinations of Phone Number',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Each digit -> try all its letters, recurse to next digit',
    memoryHook: 'Digit by digit, letter by letter',
  },
  {
    problemId: 'n-queens',
    problemName: 'N-Queens',
    category: 'backtracking',
    pattern: 'Backtracking',
    oneLiner: 'Place one queen per row, track cols and diagonals',
    memoryHook: 'Diagonals: (r-c) and (r+c) are unique',
  },

  // Graphs (80-92)
  {
    problemId: 'number-of-islands',
    problemName: 'Number of Islands',
    category: 'graphs',
    pattern: 'Graph DFS',
    oneLiner: 'Find \'1\', count island, sink entire island (mark visited)',
    memoryHook: 'Find land, sink island, count',
  },
  {
    problemId: 'clone-graph',
    problemName: 'Clone Graph',
    category: 'graphs',
    pattern: 'Graph DFS',
    oneLiner: 'Map old node to new node, clone neighbors recursively',
    memoryHook: 'Map the clone, wire the connections',
  },
  {
    problemId: 'max-area-of-island',
    problemName: 'Max Area of Island',
    category: 'graphs',
    pattern: 'Graph DFS',
    oneLiner: 'DFS returns area, track max',
    memoryHook: 'Count while sinking',
  },
  {
    problemId: 'pacific-atlantic-water-flow',
    problemName: 'Pacific Atlantic Water Flow',
    category: 'graphs',
    pattern: 'Graph DFS',
    oneLiner: 'DFS inward from each ocean edge, find intersection',
    memoryHook: 'Water flows up from the edges',
  },
  {
    problemId: 'surrounded-regions',
    problemName: 'Surrounded Regions',
    category: 'graphs',
    pattern: 'Graph DFS',
    oneLiner: 'Mark border-connected O\'s safe, flip the rest',
    memoryHook: 'Save the edges, capture the rest',
  },
  {
    problemId: 'rotting-oranges',
    problemName: 'Rotting Oranges',
    category: 'graphs',
    pattern: 'Graph BFS',
    oneLiner: 'All rotten start in queue, BFS level = minute',
    memoryHook: 'Rot spreads simultaneously',
  },
  {
    problemId: 'walls-and-gates',
    problemName: 'Walls and Gates',
    category: 'graphs',
    pattern: 'Graph BFS',
    oneLiner: 'BFS from all gates (0s) simultaneously',
    memoryHook: 'Distance ripples outward from gates',
  },
  {
    problemId: 'course-schedule',
    problemName: 'Course Schedule',
    category: 'graphs',
    pattern: 'Topological Sort',
    oneLiner: 'DFS with 3 states: unvisited, visiting, visited. Cycle if hit "visiting".',
    memoryHook: 'Visiting a visitor = cycle',
  },
  {
    problemId: 'course-schedule-ii',
    problemName: 'Course Schedule II',
    category: 'graphs',
    pattern: 'Topological Sort',
    oneLiner: 'DFS, add to result after processing all prerequisites',
    memoryHook: 'Post-order gives reverse topo order',
  },
  {
    problemId: 'redundant-connection',
    problemName: 'Redundant Connection',
    category: 'graphs',
    pattern: 'Union Find',
    oneLiner: 'If already connected when adding edge, it\'s redundant',
    memoryHook: 'Already friends? Extra edge!',
  },
  {
    problemId: 'number-of-connected-components-in-an-undirected-graph',
    problemName: 'Number of Connected Components',
    category: 'graphs',
    pattern: 'Union Find',
    oneLiner: 'Count unique parents (or DFS starts)',
    memoryHook: 'Count the roots',
  },
  {
    problemId: 'graph-valid-tree',
    problemName: 'Graph Valid Tree',
    category: 'graphs',
    pattern: 'Union Find',
    oneLiner: 'Tree = n-1 edges + no cycle',
    memoryHook: 'n-1 edges, no cycle, one component',
  },
  {
    problemId: 'word-ladder',
    problemName: 'Word Ladder',
    category: 'graphs',
    pattern: 'Graph BFS',
    oneLiner: 'Each word = node, edges = 1 char different, BFS for shortest',
    memoryHook: 'One letter at a time, BFS for shortest',
  },

  // Advanced Graphs (93-98)
  {
    problemId: 'reconstruct-itinerary',
    problemName: 'Reconstruct Itinerary',
    category: 'advanced-graphs',
    pattern: 'Graph DFS',
    oneLiner: 'DFS, add to result when backtracking (no more edges)',
    memoryHook: 'Use all tickets, write backwards',
  },
  {
    problemId: 'min-cost-to-connect-all-points',
    problemName: 'Min Cost to Connect All Points',
    category: 'advanced-graphs',
    pattern: 'Greedy',
    oneLiner: 'Greedily add closest unvisited point (Prim\'s)',
    memoryHook: 'Closest neighbor first',
  },
  {
    problemId: 'network-delay-time',
    problemName: 'Network Delay Time',
    category: 'advanced-graphs',
    pattern: 'Heap',
    oneLiner: 'Shortest path to all nodes (Dijkstra), return max',
    memoryHook: 'Dijkstra, then find the slowest',
  },
  {
    problemId: 'swim-in-rising-water',
    problemName: 'Swim in Rising Water',
    category: 'advanced-graphs',
    pattern: 'Binary Search',
    oneLiner: 'Minimize maximum elevation on path',
    memoryHook: 'Wait for water, walk to the peak',
  },
  {
    problemId: 'alien-dictionary',
    problemName: 'Alien Dictionary',
    category: 'advanced-graphs',
    pattern: 'Topological Sort',
    oneLiner: 'Compare adjacent words for char ordering, topo sort',
    memoryHook: 'Words give edges, topo gives order',
  },
  {
    problemId: 'cheapest-flights-within-k-stops',
    problemName: 'Cheapest Flights Within K Stops',
    category: 'advanced-graphs',
    pattern: 'DP',
    oneLiner: 'Track (cost, stops), allow revisit with fewer stops',
    memoryHook: 'Stops matter, not just cost',
  },

  // 1D Dynamic Programming (99-110)
  {
    problemId: 'climbing-stairs',
    problemName: 'Climbing Stairs',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'ways(n) = ways(n-1) + ways(n-2)',
    memoryHook: 'Fibonacci in disguise',
  },
  {
    problemId: 'min-cost-climbing-stairs',
    problemName: 'Min Cost Climbing Stairs',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[i] = cost[i] + min(dp[i-1], dp[i-2])',
    memoryHook: 'Pay current, pick cheaper past',
  },
  {
    problemId: 'house-robber',
    problemName: 'House Robber',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[i] = max(rob this + dp[i-2], skip this dp[i-1])',
    memoryHook: 'Rob or skip, can\'t do both neighbors',
  },
  {
    problemId: 'house-robber-ii',
    problemName: 'House Robber II (Circular)',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Run House Robber on [1:] and [:-1], take max',
    memoryHook: 'Circle = two lines, skip one end each',
  },
  {
    problemId: 'longest-palindromic-substring',
    problemName: 'Longest Palindromic Substring',
    category: '1d-dynamic-programming',
    pattern: 'Two Pointers',
    oneLiner: 'Try each center (and pair), expand outward',
    memoryHook: 'Expand from every possible middle',
  },
  {
    problemId: 'palindromic-substrings',
    problemName: 'Palindromic Substrings',
    category: '1d-dynamic-programming',
    pattern: 'Two Pointers',
    oneLiner: 'Count valid expansions from each center',
    memoryHook: 'Count expansions, not just longest',
  },
  {
    problemId: 'decode-ways',
    problemName: 'Decode Ways',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid double)',
    memoryHook: 'One digit or two? Add valid paths.',
  },
  {
    problemId: 'coin-change',
    problemName: 'Coin Change',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[amount] = 1 + min(dp[amount - coin] for each coin)',
    memoryHook: 'Try all coins, pick minimum',
  },
  {
    problemId: 'maximum-product-subarray',
    problemName: 'Maximum Product Subarray',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Negative x negative = positive, so track both min AND max',
    memoryHook: 'Max can become min and vice versa',
  },
  {
    problemId: 'word-break',
    problemName: 'Word Break',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[i] = any(dp[j] and s[j:i] in dict)',
    memoryHook: 'Can I break here? Check all prefixes.',
  },
  {
    problemId: 'longest-increasing-subsequence',
    problemName: 'Longest Increasing Subsequence',
    category: '1d-dynamic-programming',
    pattern: 'Binary Search',
    oneLiner: 'Binary search: maintain sorted subsequence, replace to extend',
    memoryHook: 'Patient sorting (pile game)',
  },
  {
    problemId: 'partition-equal-subset-sum',
    problemName: 'Partition Equal Subset Sum',
    category: '1d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Can we reach sum/2 with subset?',
    memoryHook: 'Half the sum = balanced partition',
  },

  // 2D Dynamic Programming (111-121)
  {
    problemId: 'unique-paths',
    problemName: 'Unique Paths',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[r][c] = dp[r-1][c] + dp[r][c-1]',
    memoryHook: 'Sum of paths from top and left',
  },
  {
    problemId: 'longest-common-subsequence',
    problemName: 'Longest Common Subsequence',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Match -> diagonal + 1. No match -> max(up, left).',
    memoryHook: 'Match = diagonal bonus',
  },
  {
    problemId: 'best-time-to-buy-and-sell-stock-with-cooldown',
    problemName: 'Best Time to Buy/Sell Stock with Cooldown',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Three states: hold, sold (cooldown next), ready',
    memoryHook: 'Hold, sold, chill',
  },
  {
    problemId: 'coin-change-ii',
    problemName: 'Coin Change II',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Iterate coins FIRST to avoid counting same combo twice',
    memoryHook: 'Coins outer, amounts inner',
  },
  {
    problemId: 'target-sum',
    problemName: 'Target Sum',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Find subset with sum = (total + target) / 2',
    memoryHook: 'Transform to subset sum',
  },
  {
    problemId: 'interleaving-string',
    problemName: 'Interleaving String',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'dp[i][j] = can s1[:i] and s2[:j] form s3[:i+j]',
    memoryHook: 'Both pointers progress through s3',
  },
  {
    problemId: 'longest-increasing-path-in-a-matrix',
    problemName: 'Longest Increasing Path in Matrix',
    category: '2d-dynamic-programming',
    pattern: 'Tree DFS',
    oneLiner: 'DFS from each cell, only move to strictly greater',
    memoryHook: 'Memoize the longest path from each cell',
  },
  {
    problemId: 'distinct-subsequences',
    problemName: 'Distinct Subsequences',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Match -> dp[i-1][j-1] + dp[i-1][j]. No match -> dp[i-1][j].',
    memoryHook: 'Match = use it + skip it',
  },
  {
    problemId: 'edit-distance',
    problemName: 'Edit Distance',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Match -> diagonal. Else -> 1 + min(insert, delete, replace)',
    memoryHook: 'Three choices when mismatch',
  },
  {
    problemId: 'burst-balloons',
    problemName: 'Burst Balloons',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: 'Think of LAST balloon to burst in range',
    memoryHook: 'Last to pop, not first',
  },
  {
    problemId: 'regular-expression-matching',
    problemName: 'Regular Expression Matching',
    category: '2d-dynamic-programming',
    pattern: 'DP',
    oneLiner: '\'*\' = zero matches (dp[i][j-2]) or one+ (dp[i-1][j] if char matches)',
    memoryHook: 'Star can vanish or eat more',
  },

  // Greedy (122-129)
  {
    problemId: 'maximum-subarray',
    problemName: 'Maximum Subarray',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'curSum = max(num, curSum + num). Reset if negative.',
    memoryHook: 'Negative baggage? Start fresh.',
  },
  {
    problemId: 'jump-game',
    problemName: 'Jump Game',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'Track farthest reachable, fail if position > reach',
    memoryHook: 'Can I reach here from before?',
  },
  {
    problemId: 'jump-game-ii',
    problemName: 'Jump Game II',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'Jump when reaching current boundary, update boundary to farthest',
    memoryHook: 'Count jumps at boundaries',
  },
  {
    problemId: 'gas-station',
    problemName: 'Gas Station',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'If total gas >= total cost, solution exists. Reset start when current goes negative.',
    memoryHook: 'Enough total? Find the start.',
  },
  {
    problemId: 'hand-of-straights',
    problemName: 'Hand of Straights',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'Start groups from smallest card, decrement counts',
    memoryHook: 'Smallest first, complete groups',
  },
  {
    problemId: 'merge-triplets-to-form-target-triplet',
    problemName: 'Merge Triplets to Form Target',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'Only use triplets where ALL values <= target values',
    memoryHook: 'Filter valid, collect matches',
  },
  {
    problemId: 'partition-labels',
    problemName: 'Partition Labels',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'Partition ends when we\'ve seen all occurrences of chars in it',
    memoryHook: 'Extend to last occurrence of every char seen',
  },
  {
    problemId: 'valid-parenthesis-string',
    problemName: 'Valid Parenthesis String',
    category: 'greedy',
    pattern: 'Greedy',
    oneLiner: 'Track possible range of open count. Valid if 0 in range at end.',
    memoryHook: 'Star = flexibility in count',
  },

  // Intervals (130-135)
  {
    problemId: 'insert-interval',
    problemName: 'Insert Interval',
    category: 'intervals',
    pattern: 'Intervals',
    oneLiner: 'Add before, merge overlapping, add after',
    memoryHook: 'Before, merge, after',
  },
  {
    problemId: 'merge-intervals',
    problemName: 'Merge Intervals',
    category: 'intervals',
    pattern: 'Intervals',
    oneLiner: 'Sort by start, extend end if overlapping',
    memoryHook: 'Sort, then swallow overlaps',
  },
  {
    problemId: 'non-overlapping-intervals',
    problemName: 'Non-overlapping Intervals',
    category: 'intervals',
    pattern: 'Greedy',
    oneLiner: 'Keep intervals that end earliest (sort by end)',
    memoryHook: 'End early, fit more',
  },
  {
    problemId: 'meeting-rooms',
    problemName: 'Meeting Rooms',
    category: 'intervals',
    pattern: 'Intervals',
    oneLiner: 'Sort by start, check if any meeting starts before previous ends',
    memoryHook: 'Sort, then scan for conflicts',
  },
  {
    problemId: 'meeting-rooms-ii',
    problemName: 'Meeting Rooms II',
    category: 'intervals',
    pattern: 'Heap',
    oneLiner: 'Heap tracks ongoing meetings, reuse room if start >= earliest end',
    memoryHook: 'Heap of end times = rooms in use',
  },
  {
    problemId: 'minimum-interval-to-include-each-query',
    problemName: 'Minimum Interval to Include Each Query',
    category: 'intervals',
    pattern: 'Heap',
    oneLiner: 'For each query (sorted), add valid intervals to heap by size',
    memoryHook: 'Smallest valid interval wins',
  },

  // Math & Geometry (136-143)
  {
    problemId: 'rotate-image',
    problemName: 'Rotate Image',
    category: 'math-geometry',
    pattern: 'Math',
    oneLiner: '90 deg clockwise = transpose then reverse each row',
    memoryHook: 'Transpose, flip rows',
  },
  {
    problemId: 'spiral-matrix',
    problemName: 'Spiral Matrix',
    category: 'math-geometry',
    pattern: 'Math',
    oneLiner: 'Go right, down, left, up, shrink boundaries',
    memoryHook: 'Peel the onion layers',
  },
  {
    problemId: 'set-matrix-zeroes',
    problemName: 'Set Matrix Zeroes',
    category: 'math-geometry',
    pattern: 'Math',
    oneLiner: 'Mark zeros in first row/col, then zero based on marks',
    memoryHook: 'First row/col = scoreboard',
  },
  {
    problemId: 'happy-number',
    problemName: 'Happy Number',
    category: 'math-geometry',
    pattern: 'Fast & Slow Pointers',
    oneLiner: 'Sum of squared digits eventually hits 1 or cycle',
    memoryHook: 'Floyd\'s on digit sums',
  },
  {
    problemId: 'plus-one',
    problemName: 'Plus One',
    category: 'math-geometry',
    pattern: 'Math',
    oneLiner: 'Work right to left, carry if 9',
    memoryHook: '9 becomes 0, carry the 1',
  },
  {
    problemId: 'powx-n',
    problemName: 'Pow(x, n)',
    category: 'math-geometry',
    pattern: 'Math',
    oneLiner: 'x^n = (x^2)^(n/2). If n odd, multiply extra x.',
    memoryHook: 'Square and halve',
  },
  {
    problemId: 'multiply-strings',
    problemName: 'Multiply Strings',
    category: 'math-geometry',
    pattern: 'Math',
    oneLiner: 'digits[i] x digits[j] goes to position i+j+1',
    memoryHook: 'Multiply like you learned in school',
  },
  {
    problemId: 'detect-squares',
    problemName: 'Detect Squares',
    category: 'math-geometry',
    pattern: 'HashMap',
    oneLiner: 'Given diagonal, find other two corners',
    memoryHook: 'One point defines possible squares',
  },

  // Bit Manipulation (144-150)
  {
    problemId: 'single-number',
    problemName: 'Single Number',
    category: 'bit-manipulation',
    pattern: 'Bit Manipulation',
    oneLiner: 'a XOR a = 0, a XOR 0 = a. Pairs cancel, single remains.',
    memoryHook: 'XOR twins vanish',
  },
  {
    problemId: 'number-of-1-bits',
    problemName: 'Number of 1 Bits',
    category: 'bit-manipulation',
    pattern: 'Bit Manipulation',
    oneLiner: 'n & (n-1) removes lowest set bit, count iterations',
    memoryHook: 'Subtract 1 and AND to kill a bit',
  },
  {
    problemId: 'counting-bits',
    problemName: 'Counting Bits',
    category: 'bit-manipulation',
    pattern: 'DP',
    oneLiner: 'dp[i] = dp[i >> 1] + (i & 1)',
    memoryHook: 'Half the bits + last bit',
  },
  {
    problemId: 'reverse-bits',
    problemName: 'Reverse Bits',
    category: 'bit-manipulation',
    pattern: 'Bit Manipulation',
    oneLiner: 'Extract rightmost, shift into result from left',
    memoryHook: 'Pop from right, push to left',
  },
  {
    problemId: 'missing-number',
    problemName: 'Missing Number',
    category: 'bit-manipulation',
    pattern: 'Bit Manipulation',
    oneLiner: 'XOR all nums with 0..n, missing remains',
    memoryHook: 'Index and value cancel except missing',
  },
  {
    problemId: 'sum-of-two-integers',
    problemName: 'Sum of Two Integers',
    category: 'bit-manipulation',
    pattern: 'Bit Manipulation',
    oneLiner: 'a XOR b = sum without carry. (a & b) << 1 = carry. Repeat.',
    memoryHook: 'XOR adds, AND carries',
  },
  {
    problemId: 'reverse-integer',
    problemName: 'Reverse Integer',
    category: 'bit-manipulation',
    pattern: 'Math',
    oneLiner: 'Pop digits from right (% 10), push to result (* 10)',
    memoryHook: 'Mod to pop, multiply to push',
  },
];

export const getTipByProblemId = (problemId: string): AlgoTip | undefined => {
  return algoTips.find((tip) => tip.problemId === problemId);
};

export const getTipsByPattern = (pattern: Pattern): AlgoTip[] => {
  return algoTips.filter((tip) => tip.pattern === pattern);
};

export const getTipsByCategory = (category: string): AlgoTip[] => {
  return algoTips.filter((tip) => tip.category === category);
};

export const getAllPatterns = (): Pattern[] => {
  return [...new Set(algoTips.map((tip) => tip.pattern))];
};
